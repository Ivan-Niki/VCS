
============= Что такое Git =============
Git — распределённая система контроля версий, которая даёт возможность разработчикам отслеживать изменения в файлах и работать над одним проектом совместно с коллегами.
В распределённой системе налажена удалённая работа. Если с файлами основного репозитория что-то случится — проект легко восстановить из копии любого участника команды.
Она была разработана в 2005 году Линусом Торвальдсом, создателем Linux, чтобы другие разработчики могли вносить свой вклад в ядро Linux. 
Git известен своей скоростью, простым дизайном, поддержкой нелинейной разработки, полной децентрализацией и возможностью эффективно работать с большими проектами.
Подход Git к хранению данных похож на набор снимков миниатюрной файловой системы. 
Каждый раз, когда вы сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок.

В самом простом виде контроль версий — это сохранение на компьютере серии измененных файлов, например, 
с разными датами в названии, или режим отслеживания исправлений в текстовых документах.

Разработчикам часто бывает нужно вернуться к предыдущей версии кода:
- если оказывается, что решаемая задача больше не актуальна;
- если требуется внести исправления в более раннюю версию программы;
- если ошибка нашлась во время работы над новой задачей.

Если над проектом работает много людей, нужно, чтобы они могли вносить изменения в одни и те же файлы без конфликтов и потерь кода. 
Все эти задачи удобно решаются с помощью Git.

К базовым возможностям Git относятся:
- возврат к любой предыдущей версии кода;
- просмотр истории изменений;
- параллельная работа над проектом;
- backup кода.

----- Основные понятия Git -----
- Репозиторий: это хранилище, содержащее все файлы и историю изменений проекта.
- Коммит : фиксация изменений в репозитории с описанием внесенных изменений.
- Ветка (branch): отдельный поток разработки, который позволяет создавать и тестировать новые функции, не затрагивая основной код.
- Слияние (merge): объединение изменений из одной ветки в другую.


-------------- Что такое GitHub ---------------
GitHub — это облачная платформа для хостинга IT-проектов и совместной разработки, под капотом которой находится популярная система контроля версий Git, а также полноценная социальная сеть для разработчиков.
Многие путают Git и GitHub, но это не одно и то же: 
-> Git — это система (хранилище) контроля версий;
-> GitHub — это интернет-сервис (его еще называют социальной сетью для программистов), по сути использующийся
Git как удаленный Git-сервер, с которого можно получить все версии файлов проекта при удаленной разработке.

Кроме GitHub есть другие сервисы, которые используют Git, — например, Bitbucket и GitLab. 
Вы можете разместить Git-репозиторий на любом из них.


Краткая схема работы над проектом происходит так: 
- Разработчик создаёт новую ветку репозитория, работает в ней, после чего делает коммит и пушит.
- Создаёт пулл реквест (pull request).
- Ревьюер перепроверяет работу и её одобряет, после чего объединяет с основной веткой.


---- Как проверить, установлен ли git в вашей ОС? ----
В терминала необходимо ввести команду:   
-> git --version

--- После установки Git необходимо настроить ИМЯ и EMAIL автора ---
-> git config --global user.name ИМЯ      --- ИЛИ ---     git config --global user.name "ИМЯ ФАМИЛИЯ"
-> git config --global user.email somename@gmail.com

--- Получение списка всез настроек Git ---
-> git config --list


-------------- ОБЛАСТИ GIT --------------
                                          git add                          git commit
[Working directory (рабочая директория)] --------> [Staging area (Индекс)]  -------->  [Repository (репозиторий)]

Если мы сделали изменения в файле в рабочей директории, то команда git status будет отображать этот файл в стостоянии "modified".
Мы можем отменить эти изменения с помощью следующей команды:  git checkout -- [путь к файлу]. Например:
--> git checkout -- file1.txt
То же самое можно сделать при помощи другой команды:
--> git restore file1.txt

Что бы удалить из индекса некоторые файлы используйте:
--> git restore --staged <file>
таким образом вы восстановите ваш индекс (или точнее удалите конкретные файлы из индекса), будто бы git add после последнего коммита не выполнялся для них. 
С помощью этой команды вы можете восстановить и рабочую директорию, что бы она выглядела так, будто бы после коммита не выполнялось никаких изменений. Но есть нюанс:
если вы добавили в индекс новую версию вашего файла вы не можете изменить вашу рабочую директорию, пока индекс отличается от HEAD. 
Поэтому вам сначала нужно восстановить ваш индекс и только потом рабочую директорию.





================== Создание репозиториев ===================
1) Клонировать существующий репозиторий
--> git clone <repository-URL>


2.1) Инициализировать новый репозиторий Git
--> git init
Добавить удалённый репозиторий можно параметром remote add, указав shortname и url требуемого репозитория.
--> git remote add awesomeapp https://github.com/someurl...

2.2) Отправить изменения в удаленный репозиторий
--> git push <name> <branch>


-------------- Удаление репозиториев --------------
Как быть, когда папка с проектом уже существует, но в нее нужно поместить новые данные, удалив предыдущие, или
когда Git-репозиторий на сервере больше не нужен. В таком случае осуществляется стандартное удаление.
В корне каталога с проектом необходимо избавиться от папки .git. 
Так вы удаляете только ту информацию, которая связана с Git, но сам проект остается. 
В Linux через Терминал вы должны перейти к каталогу с проектом и ввести следующую команду:
--> rm -rf .git




----------- Проверка статуса репозитория -----------
Просмотреть статус нужного репозитория можно по ключевому слову status: его действие распространяется на
подготовленные, неподготовленные и неотслеживаемые файлы.
Команда "git status" показывает состояния файлов в рабочей директории и индексе: 
- какие файлы изменены, но не добавлены в индекс; 
- какие ожидают коммита в индексе. 
Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.


------- Добавление отдельных файлов (или всех файлов) в область подготовленных файлов (stagind area) -------
--- git add ---
Команда git add добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита. 
По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита.
Добавить отдельный файл в область подготовленных файлов можно параметром add с указанием имени файла.
Например:  
--> git add somefile.js

Кроме того, можно добавить все файлы и папки в эту область, предоставив wildcard . вместо имени файла:
--> git add .



----------------------- Игнорирование файлов ---------------------

В процессе работы над любым проектом в директории с кодом создаются файлы, которые не являются частью исходного кода. 
Все эти файлы можно условно разделить на несколько групп:

1) Инструментарий
   - Служебные файлы, добавляемые операционной системой — например, .DS_Store в MacOS
   - Конфигурационные и временные файлы редакторов — например, .idea или .vscode
2) Временные файлы
   - Логи — в них содержится полезная информация для отладки, которая собирается во время запуска и работы приложения
   - Кеши — файлы, которые нужны для ускорения разных процессов
3) Артефакты
   - Результаты сборки проекта — например, после компиляции или сборки фронтенда
   - Зависимости, которые устанавливаются во время разработки — например, node_modules или vendor
   - Результаты выполнения тестов — например, информация о покрытии кода тестами

Все это в обычной ситуации не должно попадать в репозиторий. Эти файлы можно проигнорировать в git-репозитории.

Как правило, эти файлы не несут никакой пользы с точки зрения исходного кода. Они создаются:
- Автоматически (кеши, логи)
- По запросу (например, скачиваются зависимости или собирается проект)

Главная проблема с этими файлами в их постоянном изменении — особенно при очень больших размерах проекта. 
Если добавлять их в репозиторий, то практически в каждом коммите будут не только изменения исходного кода, 
но и пачка изменений в этих файлах. Читать историю таких коммитов крайне сложно.

Git позволяет гибко настраивать игнорирование определенных файлов и директорий. 
Делается это с помощью файла .gitignore, который нужно создать в корне проекта. 
В этот файл с помощью текстового редактора добавляются имена файлов и директорий, которые надо игнорировать:

Например:
# В этом файле можно оставлять комментарии
# Имя файла .gitignore
# Файл нужно создать самостоятельно

# Каждая строчка — это шаблон, по которому происходит игнорирование

# Игнорируем файл в любой директории проекта
access.log

# Игнорируем директорию в любой директории проекта
node_modules/

# Игнорируем каталог в корне рабочей директории
/coverage/

# Игнорируем все файлы с расширением sqlite3 в директории db
/db/*.sqlite3
# При этом не игнорируются такие же файлы внутри любого вложенного каталога в db
# Например, /db/something/lala.sqlite3

# Игнорировать все .txt файлы в каталоге doc/ на всех уровнях вложенности
doc/**/*.txt

Git поддерживает игнорирование файлов, но сам его не настраивает. 
Для игнорирования файлов и директорий, программист должен создать файл .gitignore в корне проекта и добавить его в репозиторий. 

Продолжим работать с .gitignore:
touch .gitignore
# Добавляем в файл правила игнорирования по примеру выше.
git add .gitignore
git commit -m 'update gitignore'
Как только .gitignore создан и в него добавлен какой-то файл или директория, игнорирование заработает автоматически. 
Все новые файлы, попадающие под игнорирование, не отобразятся в выводе команды git status.

Иногда бывает такое, что программист случайно уже добавил в репозиторий файл, который нужно проигнорировать. 
В этой ситуации недостаточно обновить правила игнорирования. 
Дополнительно придется удалить файл или директорию из Git с помощью git rm и закоммитить.

------- Если игнорируемые файлы уже есть в последнем коммите -------
Здесь reset не сработает, нужен rm. Аргумент --cached заставляет Git удалить файл из индекса, но не трогать рабочую область. 
То есть он буквально индексирует удаление файла, хотя этого удаления не было. 
Если сделать это с файлом, который не игнорируется, то после коммита он будет в категории неотслеживаемых (untracked).
--> git rm --cached <file-name>

Если нужно убрать целую игнорируемую папку, добавляем ключ -r:
--> git rm -r --cached <path>



Самый простой путь - удалить из кэша ВСЕ файлы, и добавить заново с учетом gitignore. 
На всё про всё 2 команды.
git rm -rf --cached .
git add .
потом закоммитить:
git commit -m "fix gitignore"




====================== РАБОТА С КОММИТАМИ ======================

--------- Внесение изменений (commit) однострочным сообщением или через редактор ---------
При создании коммита в репозитории можно добавить однострочное сообщение с помощью параметра commit с флагом -m.
Само сообщение вводится непосредственно после флага, в кавычках.
--> git commit -m "Your short summary about the commit"

Также можно открыть текстовый редактор в терминале для написания полного сообщения коммита. 
Оно может состоять из нескольких строк текста, в котором подробно характеризуются изменения, внесённые в репозиторий.
--> git commit


--------- Изменение последнего коммита --------- 
Внести изменения в последний коммит можно параметром commit с флагом --amend. 
Например, вы записали изменения, внесённые в ряд файлов, и поняли, что допустили ошибку в сообщении коммита. 
В этом случае можете воспользоваться указанной командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок.
--> git commit --amend -m "Updated message for the previous commit"

Также можно вносить изменения в файлы, отправленные ранее. 
Например, вы изменили несколько файлов в ряде папок и хотите их записать как единый снимок, но забыли добавить в коммит одну из папок. 
Чтобы исправить такую ошибку, достаточно подготовить для фиксации остальные файлы и папки и создать коммит с флагами --amend и --no-edit.

Например:
------------------------------------------------------------
git add dir1
git commit

# Here you forgot to add dir2 to commit, you can execute the
following command to amend the other files and folders.

git add dir2
git commit --amend --no-edit
-------------------------------------------------------------
Флаг --no-edit позволит внести в коммит поправку без изменения сообщения коммита. В этом случае итоговый коммит заменит неполный, а выглядеть это будет так, как будто мы отправили изменения ко всем файлам в нужных папках как единый снимок.


--------- Просмотр истории коммитов с изменениями ----------
Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. 
Он отображает список последних коммитов в порядке выполнения. 
Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в каждый файл.
--> git log -p

--> git log   ->   посмотреть историю коммитов;
--> git log -1  ->   посмотреть в истори только один последний коммит;
--> git log -3  ->   посмотреть в истори только три последних коммита;
--> git log --oneline   ->  посмотреть историю коммитов (сокращённый вариант);
--> git log --oneline --graph (--decorate)   ->  посмотреть историю коммитов (сокращённый вариант) в виде
графика для текущей ветки.
--> git log --oneline --graph --all (--decorate)   ->  посмотреть историю коммитов (сокращённый вариант) в виде
графика по всем веткам.



--------- Просмотр заданного коммита ----------
Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. 
Значение хеша уникально для каждого коммита, созданного в вашем репозитории. Например:
--> git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29

Также можно использовать сокращённый хеш:
--> git show 1af17e



--------- Просмотр изменений до коммита ----------
Можно просматривать список изменений, внесённых в репозиторий, используя параметр diff. 
По умолчанию отображаются только изменения, не подготовленные для фиксации.
--> git diff

Для просмотра подготовленных изменений необходимо добавить флаг --staged.
--> git diff --staged

Также можно указать имя файла как параметр и просмотреть изменения, внесённые только в этот файл.
--> git diff somefile.js


--------- Откат последнего коммита ----------
Откатить последний коммит можно с помощью параметра revert. 
Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.
--> git revert HEAD





Чтобы удалить файлы из индекса вы можете использовать 2 команды: git reset и git restore.
-> git restore — восстановит файлы рабочего дерева.
-> git reset — сбрасывает текущий HEAD до указанного состояния.
По сути вы можете добиться одного и того же с помощью обеих команд.


У git reset есть три режима: --soft, --mixed и --hard. Я рассматриваю их как три стадии:

Стадия 1. git reset --soft --> обновление HEAD (обновление коммитов в истории репозитория).
Стадия 2. git reset --mixed --> обновление индекса (staging area).   (--mixed используется по умолчанию).
Стадия 3. git reset --hard --> обновление рабочей директории.

1) git reset --soft HEAD~ -> удалить последний коммит из истории, НО НЕ удалять изменения, связанные с этим коммитом, из staging area и working directory;
git reset --soft HEAD~4 -> удалить 4 последних коммита из истории, НО НЕ удалять изменения, связанные с этими коммитами, из staging area и working directory;

2) git reset HEAD~  или  git reset --mixed HEAD~  -> удалить последний коммит из истории, также удалить изменения, связанные с этим коммитом, из staging area, НО НЕ удалять изменения из working directory;

3) git reset --hard HEAD~ -> удалить последний коммит из истории и удалить изменения из staging area и working directory;
git reset --hard HEAD~2 -> удалить 2 последних коммита из истории и удалить изменения, связанные с этими коммитами, из staging area и working directory;


Чтобы удалить из индекса некоторые файлы используйте следующую команду:
git restore --staged <file>  - данная команда удалит из staging area отслеживаемые изменения в файле.



===================== РАБОТА С ВЕТКАМИ ====================

------------ Создание веток  -----------
--> git branch feature-1 - создать ветку с названием feature-1;


------------ Переключение между ветками -----------
--> git checkout feature-1 - переключиться на ветку feature-1;
   
--> git switch feature-1 - переключиться на ветку test;


------------ Создание ветки с переключением на неё -----------
--> git checkout -b test - создать и переключиться на ветку test;
   
--> git switch -c test - создать и переключиться на ветку test;
   

------------ Просмотр списка веток -----------
Можно просматривать полный список веток, используя параметр branch. 
Команда отобразит все ветки, отметит текущую звёздочкой (*) и выделит её цветом.
--> git branch

Также можно вывести список всех веток (на удалённом репозитории (remote repository) и на локальном) 
с помощью флага -a.
--> git branch -a

Можно просмотреть все ветки только на удалённом репозитории (remote repository);
--> git branch -r       -> просмотр всех веток только на удалённом репозитории (remote repository).


------------ Запушить все ветки (или одну ветку) на внешний репозиторий ------------
--> git push origin --all


------------ Отправка новой ветки в удалённый репозиторий ------------
Передать новую ветку в удалённый репозиторий можно параметром push с флагом -u, указав имя репозитория и имя ветки.
--> git push -u origin new_branch


-----------------------------------------------------------
# Создать новую локальную ветку
git checkout -b branch_name
# внести изменения в файлы, затем добавить их и закоммитить
git add *
git commit -m "Commit message"
# запушить новую локальную ветку в репу
git push origin branch_name
-----------------------------------------------------------


------------ Слияние двух веток -----------
Объединить две ветки можно параметром merge с указанием имени ветки. 
Команда объединит указанную ветку с основной.
--> git merge existing_branch_name

Например:
--> git merge feature-1    ->  влить ветку feature-1 с её коммитами в ту ветку, на которой мы находимся (например, master).


------------ Прекращение слияния при конфликте -----------
Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.
--> git merge --abort

Также при конфликте слияния можно использовать параметр reset, чтобы восстановить конфликтующие файлы до стабильного состояния.
--> git reset

Для того, чтобы продолжить процесс слияния веток после разрешения мердж-конфликтов, нужно ввести команду:
--> git merge --continue


------------ Удаление ветки -----------
Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. 
Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. 
Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. 
Этот защитный механизм предотвращает потерю доступа к файлам.
--> git branch -d <existing_branch_name>

Для принудительного удаления ветки используется флаг -D с заглавной буквой. 
В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.
--> git branch -D <existing_branch_name>

Перед удалением ветки мы можем проверить, какие ветки были смержены:
--> git branch --merged      - данная команда выведет список веток, которые не были смержены.

Также мы можеи посмотреть список НЕсмерженых веток:
--> git branch --no-merged


----------- Удаление ветки в remote repository -----------
Чтобы избавиться от удалённой ветки, используйте параметр push с флагом --delete, указав имя удалённого репозитория и имя ветки.
--> git push --delete origin existing_branch_name


Если ваш коллега удалил ветку во внешнем репозитории, то ваш локальный репозиторий всё равно будет хранить информацию об этой ветке.
Чтобы удалить инормацию на вашем локальном репозитории в командной строке нужно вызвать:
--> git remote prune origin



----------- Переименование ветки -----------
Для того, чтобы переименовать ветку, нужно сначала переключиться на эту ветку, а затем прописать команду:
--> git branch -m <new_branch_name>




===================== МЕРДЖ-КОНФЛИКТЫ ====================

Выявление конфликтов слияния
На следующем примере показано, как система Git выводит небольшое описательное сообщение о возникновении КОНФЛИКТА. 
Чтобы лучше разобраться в проблеме, можно выполнить команду git status.

$ git status
On branch main
You have unmerged paths.
(fix conflicts and run "git commit")
(use "git merge --abort" to abort the merge)

Unmerged paths:
(use "git add <file>..." to mark resolution)

both modified:   app-file.txt


Вывод команды git status говорит о том, что из-за конфликта не удалось слить пути. 
Теперь файл app-file.txt отображается как измененный. Давайте изучим этот файл и посмотрим, что изменилось.

$ cat app-file.txt
<<<<<<< HEAD
this is some content to mess with
content to append
=======
totally different content to merge later
>>>>>>> new_branch_to_merge_later


Для просмотра содержимого файла app-file.txt воспользуемся командой cat. 
Видно, что в файле появились новые странные дополнения:

<<<<<<< HEAD
=======
>>>>>>> new_branch_to_merge_later

Эти новые строки можно рассматривать как «разделители конфликта». 
Строка ======= является «центром» конфликта.
Все содержимое между этим центром и строкой <<<<<<< HEAD находится в текущей ветке main, на которую ссылается указатель HEAD. 
А все содержимое между центром и строкой >>>>>>> new_branch_to_merge_later является содержимым ветки для слияния.


----------- Разрешение конфликтов слияния -----------
Самый простой способ разрешить конфликт — отредактировать конфликтующий файл. 
Откройте файл app-file.txt в привычном редакторе. В нашем примере просто удалим все разделители конфликта.
Измененное содержимое файла app-file.txt будет выглядеть следующим образом:

this is some content to mess with
content to append
totally different content to merge later

После редактирования файла выполните команду git add app-file.txt, чтобы добавить новое объединенное содержимое в раздел проиндексированных файлов. 

Для завершения слияния создайте новый коммит, выполнив следующую команду:
git commit -m "merged and resolved the conflict in app-file.txt"

Git обнаружит, что конфликт разрешен, и создаст новый коммит слияния для завершения процедуры слияния.


------------ Команды Git, с помощью которых можно разрешить конфликты слияния -----------
--> git status
Команда status часто используется во время работы с Git и помогает идентифицировать конфликтующие во время слияния файлы.

--> git log --merge
При передаче аргумента --merge для команды git log будет создан журнал со списком конфликтов коммитов между ветками, для которых выполняется слияние.

--> git diff
Команда diff помогает найти различия между состояниями репозитория/файлов. Она полезна для выявления и предупреждения конфликтов слияния.


------------ Команды для случаев, когда конфликты Git возникают во время слияния -----------
--> git merge --abort
При выполнении команды git merge с опцией --abort процесс слияния будет прерван, а ветка вернется к состоянию, 
в котором она находилась до начала слияния.

--> git reset
Команду git reset можно использовать для разрешения конфликтов, возникающих во время выполнения слияния, 
чтобы восстановить заведомо удовлетворительное состояние конфликтующих файлов.




=============== Отправка изменений в удалённый репозиторий ===============
Отправлять изменения в удалённый репозиторий можно параметром push с указанием имени репозитория и ветки.
--> git push origin main
// Эта команда передаёт локальные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта.


------------ Получение изменений из удалённого репозитория -----------
Для загрузки изменений из удалённого репозитория используется параметр pull. 
Он скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией.
--> git pull

Также можно просмотреть подробные сведения о загруженных файлах с помощью флага --verbose.
--> git pull --verbose


